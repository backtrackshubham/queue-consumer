#!/usr/bin/env node

//var parseArgs = require('minimist');
var amqp = require('amqplib');
const meow = require('meow');
var Keen = require('keen-tracking');

const cli = meow(`
  CLI queue consumer. Connects to a RabbitMQ queue and outputs
  messages as JSON to standard output.

  Usage
    $ consumer <options>

  Options
    -v, --vhost     RabbitMQ virtual host name
    -u, --user      Username
    -p, --password  Password
    -q, --queue     RabbitMQ queue name
    -h, --hostname  RabbitMQ hostname
    -o, --port      RabbitMQ port
    -a, --ack       Acknowledge messages and remove from queue

  Examples
    $ consumer -v {VirtualHost} -u {UserName} -p {Password} -q {QueueName}

`, {
        unknown: handleUnknown,
        default: { hostname: 'rabbitmq-us-east-1-production.hub.bitbrew.com', port: '4443', ack: false, keenstream: 'events' },
        string: ['vhost', 'user', 'password', 'queue', 'hostname', 'port', 'keenstream', 'keenpid', 'keenkey'],
        boolean: ['ack'],
        alias: { v: 'vhost', u: 'user', p: 'password', q: 'queue', h: 'hostname', o: 'port', a: 'ack' },
    });

function validateArguments(args) {
    if(!(args.user && args.password && args.hostname && args.port && args.vhost && args.queue)) {
        cli.showHelp(1);
    }

    return args;
}

function handleUnknown(p) {
    console.dir(p);
    cli.showHelp(1);
}

function connect(args) {
    var open = amqp.connect(`amqp://${args.user}:${args.password}@${args.hostname}:${args.port}/${args.vhost}?heartbeat=30`);

    var client = createKeenClient();
    client.queueCapacity(5000);
    client.queueInterval(2);

    process.on('SIGINT', function() {
        console.log("Caught interrupt signal");

        if(args.keenpid && args.keenkey) {
          console.log("Recording any deferred events");
          client.recordDeferredEvents();
        }

        process.exit();
    });

    // Consumer
    open.then(function(conn) {
        var ok = conn.createChannel();
        conn.on('error', function(err) {
            if(err.message === 'Unexpected close') {
                console.log('Connection closed. Reconnecting...');
                connect(args);
            } else {
                console.log(err);
								connect(args);
            }
        });

        ok = ok.then(function(ch) {
            console.log('Connected.')
            ch.checkQueue(args.queue);
            ch.consume(args.queue, function(msg) {
                if (msg !== null) {
                    var eventJson = JSON.parse(msg.content);
                    console.log(JSON.stringify(eventJson, null, 4));
                    if(args.keenpid && args.keenkey) {
                      sendKeenEvent(eventJson);
                    }
                    if (args.ack === true) {
                        ch.ack(msg);
                    }
                }
            });
        });
        return ok;
    })

    function createKeenClient() {
      return new Keen({
          projectId: args.keenpid,
          writeKey: args.keenkey
      });
    }

    function sendKeenEvent(event) {
      // Add the keen object to the event
      event.keen = {};
      try {
        // Try to add timestamp info for TCP events
        if(event.body.timestamp != null) {
          event.keen.timestamp = event.body.timestamp;
        } else {
          throw "Doesn't exist"
        }
      } catch(e){
        try {
          // Try to add timestamp info for UDP events
          if(event.body.header.timestamp != null) {
            event.keen.timestamp = event.body.header.timestamp;
          } else {
            throw "Doesn't exist"
          }
        } catch(e) {
          try {
            // Use the ingestion timestamp for all others
            if(event.header.ingestionTimestamp != null) {
              event.keen.timestamp = event.header.ingestionTimestamp;
            } else {
              throw "Doesn't exist"
            }
          } catch(e){}
        }
      }

      try {
        // Try to add location info for TCP relative time events
        if(event.body.pidData.GpsReading.longitude != null && event.body.pidData.GpsReading.latitude != null) {
          event.keen.location = [event.body.pidData.GpsReading.longitude, event.body.pidData.GpsReading.latitude];
        } else {
          throw "Doesn't exist"
        }
      } catch(e){
        try {
          // Location for TCP absolute time events
          if(event.body.gps.longitude != null && event.body.gps.latitude != null) {
            event.keen.location = [event.body.gps.longitude, event.body.gps.latitude];
          } else {
            throw "Doesn't exist"
          }
        } catch(e){
          try {
            // Location for UDP events
            if(event.body.header.longitude != null && event.body.header.latitude != null) {
              event.keen.location = [event.body.header.longitude, event.body.header.latitude];
            } else {
              throw "Doesn't exist"
            }
          } catch(e){}
        }
      }

      //console.log(JSON.stringify(event, null, 4));
      client.deferEvent(args.keenstream, event);
    }
}

connect(validateArguments(cli.flags));
